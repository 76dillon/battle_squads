// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: matches.sql

package store

import (
	"context"
	"database/sql"
)

const completeMatch = `-- name: CompleteMatch :one
UPDATE matches
SET
  state = 'COMPLETED',
  completed_at = now(),
  winner_player_id = $2,
  current_actor_player_id = NULL
WHERE id = $1
RETURNING
  id,
  state,
  created_at,
  started_at,
  completed_at,
  player1_id,
  player2_id,
  winner_player_id,
  current_turn_number,
  current_actor_player_id
`

type CompleteMatchParams struct {
	ID             int64
	WinnerPlayerID sql.NullInt64
}

func (q *Queries) CompleteMatch(ctx context.Context, arg CompleteMatchParams) (Match, error) {
	row := q.db.QueryRowContext(ctx, completeMatch, arg.ID, arg.WinnerPlayerID)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Player1ID,
		&i.Player2ID,
		&i.WinnerPlayerID,
		&i.CurrentTurnNumber,
		&i.CurrentActorPlayerID,
	)
	return i, err
}

const createMatch = `-- name: CreateMatch :one
INSERT INTO matches (
    state,
    player1_id,
    player2_id,
    current_turn_number,
    current_actor_player_id
) VALUES (
    'PENDING',
    $1,                -- player1_id
    $2,                -- player2_id
    0,
    NULL
)
RETURNING
    id,
    state,
    created_at,
    started_at,
    completed_at,
    player1_id,
    player2_id,
    winner_player_id,
    current_turn_number,
    current_actor_player_id
`

type CreateMatchParams struct {
	Player1ID int64
	Player2ID int64
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (Match, error) {
	row := q.db.QueryRowContext(ctx, createMatch, arg.Player1ID, arg.Player2ID)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Player1ID,
		&i.Player2ID,
		&i.WinnerPlayerID,
		&i.CurrentTurnNumber,
		&i.CurrentActorPlayerID,
	)
	return i, err
}

const getMatchByID = `-- name: GetMatchByID :one
SELECT
    id,
    state,
    created_at,
    started_at,
    completed_at,
    player1_id,
    player2_id,
    winner_player_id,
    current_turn_number,
    current_actor_player_id
FROM matches
WHERE id = $1
`

func (q *Queries) GetMatchByID(ctx context.Context, id int64) (Match, error) {
	row := q.db.QueryRowContext(ctx, getMatchByID, id)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Player1ID,
		&i.Player2ID,
		&i.WinnerPlayerID,
		&i.CurrentTurnNumber,
		&i.CurrentActorPlayerID,
	)
	return i, err
}

const listMatchesForPlayer = `-- name: ListMatchesForPlayer :many
SELECT
    id,
    state,
    created_at,
    started_at,
    completed_at,
    player1_id,
    player2_id,
    winner_player_id,
    current_turn_number,
    current_actor_player_id
FROM matches
WHERE player1_id = $1 OR player2_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListMatchesForPlayer(ctx context.Context, player1ID int64) ([]Match, error) {
	rows, err := q.db.QueryContext(ctx, listMatchesForPlayer, player1ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.State,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Player1ID,
			&i.Player2ID,
			&i.WinnerPlayerID,
			&i.CurrentTurnNumber,
			&i.CurrentActorPlayerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startMatch = `-- name: StartMatch :one
UPDATE matches
SET
  state = 'IN_PROGRESS',
  started_at = now(),
  current_turn_number = 1,
  current_actor_player_id = $2  -- initial actor
WHERE id = $1
RETURNING
  id, state, created_at, started_at, completed_at,
  player1_id, player2_id, winner_player_id,
  current_turn_number, current_actor_player_id
`

type StartMatchParams struct {
	ID                   int64
	CurrentActorPlayerID sql.NullInt64
}

func (q *Queries) StartMatch(ctx context.Context, arg StartMatchParams) (Match, error) {
	row := q.db.QueryRowContext(ctx, startMatch, arg.ID, arg.CurrentActorPlayerID)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Player1ID,
		&i.Player2ID,
		&i.WinnerPlayerID,
		&i.CurrentTurnNumber,
		&i.CurrentActorPlayerID,
	)
	return i, err
}

const updateMatchTurnAndActor = `-- name: UpdateMatchTurnAndActor :one
UPDATE matches
SET
  current_turn_number = $2,
  current_actor_player_id = $3
WHERE id = $1
RETURNING 
  id,
  state,
  created_at,
  started_at,
  completed_at,
  player1_id,
  player2_id,
  winner_player_id,
  current_turn_number,
  current_actor_player_id
`

type UpdateMatchTurnAndActorParams struct {
	ID                   int64
	CurrentTurnNumber    int32
	CurrentActorPlayerID sql.NullInt64
}

func (q *Queries) UpdateMatchTurnAndActor(ctx context.Context, arg UpdateMatchTurnAndActorParams) (Match, error) {
	row := q.db.QueryRowContext(ctx, updateMatchTurnAndActor, arg.ID, arg.CurrentTurnNumber, arg.CurrentActorPlayerID)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Player1ID,
		&i.Player2ID,
		&i.WinnerPlayerID,
		&i.CurrentTurnNumber,
		&i.CurrentActorPlayerID,
	)
	return i, err
}
